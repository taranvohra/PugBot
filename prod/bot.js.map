{"version":3,"sources":["../src/bot.js"],"names":["message","author","equals","bot","user","content","startsWith","prefix","serverId","channel","guild","id","Servers","cachedDB","roles","member","args","substring","length","split","filter","Boolean","action","toLowerCase","hasAdminCmd","commands","admincmds","includes","servers","addqueryserver","delqueryserver","queryut99server","server","gameServers","send","catch","console","error","result","status","updateCache","cache","msg","log","onMessage","dotenv","config","PugList","disabledEvents","Client","on","API","getCopyOfDB","login","process","env","DISCORD_BOT_TOKEN","toUpdate","newCache"],"mappings":"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","file":"bot.js","sourcesContent":["import { Client, Message, User } from 'discord.js';\r\nimport dotenv from 'dotenv';\r\n// import pugEventEmitter from './pugEvent';\r\nimport { prefix, commands, pugEvents, offline } from './constants';\r\nimport {\r\n  addQueryServer,\r\n  queryUT99Server,\r\n  delQueryServer,\r\n  setPreferredChannel,\r\n} from './ut99query';\r\n// import {\r\n//   addGameType,\r\n//   delGameType,\r\n//   joinGameType,\r\n//   leaveGameType,\r\n//   listAvailablePugs,\r\n//   pickPugPlayer,\r\n//   addCaptain,\r\n//   listCurrentPickings,\r\n//   promoteAvailablePugs,\r\n// } from './pug';\r\nimport {\r\n  printServerStatus,\r\n  printGameServersList,\r\n  // printPugJoinStatus,\r\n  // printPugLeaveStatus,\r\n  // printPugStatuses,\r\n  // broadCastFilledPugs,\r\n  // broadCastDeadPugs,\r\n  // broadCastCaptainsReady,\r\n  // printPickStatus,\r\n  // printAddCaptainStatus,\r\n  // printPickingPugsStatus,\r\n  // printPromoteStatus,\r\n} from './formats';\r\nimport { checkIfRoleIsPrivileged, fixSpecialCharactersInName } from './helpers';\r\nimport { createSortedArrayFromObject } from './util';\r\nimport API from './api';\r\n\r\ndotenv.config();\r\n\r\n/**\r\n * PugList is list of pugs active at any moment on the server\r\n * Pugs are the pug(s)/gametype(s) registered on the server with their props\r\n */\r\n\r\nlet cachedDB = {};\r\nlet PugList = {};\r\n\r\nconst disabledEvents = ['TYPING_START', 'CHANNEL_UPDATE', 'USER_UPDATE'];\r\nconst bot = new Client({ disabledEvents });\r\n\r\nbot.on('ready', () => {\r\n  console.log('ready');\r\n});\r\n\r\n// bot.on(\r\n//   'presenceUpdate',\r\n//   (_, { user, guild: { channels }, presence: { status } }) => {\r\n//     if (status === 'offline') {\r\n//       if (\r\n//         Object.values(PugList).some(p => p.list.some(u => u.id === user.id))\r\n//       ) {\r\n//         const { Channel = {} } = cachedDB;\r\n//         const channel = channels.get(Channel.preferredChannel);\r\n//         const channeluser = new User(bot, {\r\n//           bot: false,\r\n//           id: user.id,\r\n//           username: user.username,\r\n//         });\r\n//         const message = new Message(\r\n//           channel,\r\n//           {\r\n//             author: channeluser,\r\n//             attachments: new Map(),\r\n//             embeds: [],\r\n//             content: `${prefix}lva ${offline}`,\r\n//           },\r\n//           bot\r\n//         );\r\n//         onMessage(message);\r\n//       }\r\n//     }\r\n//   }\r\n// );\r\n\r\nbot.on('message', onMessage);\r\n\r\nasync function onMessage(message) {\r\n  if (message.author.equals(bot.user)) return;\r\n  if (!message.content.startsWith(prefix)) return;\r\n\r\n  const {\r\n    channel: {\r\n      guild: { id: serverId },\r\n    },\r\n  } = message;\r\n\r\n  const Servers = cachedDB;\r\n  /* Register server into cache if it wasn't already in the remote DB*/\r\n  !Servers[serverId] ? (Servers[serverId] = {}) : null;\r\n\r\n  // const user = {\r\n  //   id: message.author.id,\r\n  //   username: fixSpecialCharactersInName(message.author.username),\r\n  // };\r\n\r\n  // const isUserMentioned = message.mentions.users.first();\r\n  // const userMentioned = {\r\n  //   id: isUserMentioned && isUserMentioned.id,\r\n  //   username:\r\n  //     isUserMentioned && fixSpecialCharactersInName(isUserMentioned.username),\r\n  // };\r\n\r\n  const roles = message.member.roles;\r\n  const args = message.content\r\n    .substring(prefix.length)\r\n    .split(' ')\r\n    .filter(Boolean);\r\n  const action = args[0] ? args[0].toLowerCase() : null;\r\n\r\n  const hasAdminCmd = commands.admincmds.includes(action);\r\n  // const isValidAdminCmd = hasAdminCmd && checkIfRoleIsPrivileged(roles);\r\n\r\n  switch (true) {\r\n    case commands.servers.includes(action): {\r\n      const server = Servers[serverId] || {};\r\n      const gameServers = createSortedArrayFromObject(\r\n        server['GameServers'] || {},\r\n        'timestamp'\r\n      );\r\n\r\n      message.channel\r\n        .send(printGameServersList(gameServers))\r\n        .catch(console.error + ':list:');\r\n      break;\r\n    }\r\n\r\n    case checkIfRoleIsPrivileged(roles) &&\r\n      commands.addqueryserver.includes(action): {\r\n      const server = Servers[serverId] || {};\r\n      const gameServers = createSortedArrayFromObject(\r\n        server['GameServers'] || {},\r\n        'timestamp'\r\n      );\r\n\r\n      const result = await addQueryServer(args, serverId, gameServers);\r\n      result.status ? updateCache(serverId, 'GameServers', result.cache) : '';\r\n      message.channel.send(result.msg);\r\n      break;\r\n    }\r\n\r\n    case checkIfRoleIsPrivileged(roles) &&\r\n      commands.delqueryserver.includes(action): {\r\n      const server = Servers[serverId] || {};\r\n      const gameServers = createSortedArrayFromObject(\r\n        server['GameServers'] || {},\r\n        'timestamp'\r\n      );\r\n\r\n      const result = await delQueryServer(args, serverId, gameServers);\r\n      result.status ? updateCache(serverId, 'GameServers', result.cache) : '';\r\n      message.channel.send(result.msg);\r\n      break;\r\n    }\r\n\r\n    case commands.queryut99server.includes(action): {\r\n      const server = Servers[serverId] || {};\r\n      const gameServers = createSortedArrayFromObject(\r\n        server['GameServers'] || {},\r\n        'timestamp'\r\n      );\r\n\r\n      const result = await queryUT99Server(args[1], gameServers);\r\n      message.channel\r\n        .send(result.status ? printServerStatus(result) : result.msg)\r\n        .catch(console.error + ':query:');\r\n      break;\r\n    }\r\n\r\n    /**\r\n     * P U G\r\n     *    C O M M A N D S\r\n     */\r\n\r\n    // case checkIfRoleIsPrivileged(roles) &&\r\n    //   commands.setchannel.includes(action): {\r\n    //   const channelId = message.channel.id;\r\n    //   const result = await setPreferredChannel(channelId);\r\n    //   result.status ? updateCache('Channel', result.cache) : '';\r\n    //   message.channel.send(result.msg);\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.addgametype.includes(action): {\r\n    //   const result = await addGameType(args, Pugs);\r\n    //   result.status ? updateCache('Pugs', result.cache) : '';\r\n    //   message.channel.send(result.msg);\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.delgametype.includes(action): {\r\n    //   const result = await delGameType(args, Pugs);\r\n    //   result.status ? updateCache('Pugs', result.cache) : '';\r\n    //   message.channel.send(result.msg);\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.joingametype.includes(action): {\r\n    //   if (hasAdminCmd && !isValidAdminCmd) break;\r\n\r\n    //   const { status, result, msg } = joinGameType(\r\n    //     isValidAdminCmd ? args.slice(1) : args,\r\n    //     isValidAdminCmd ? userMentioned : user,\r\n    //     Pugs,\r\n    //     PugList\r\n    //   );\r\n    //   const filledPugs = result.reduce((acc, { pug, discriminator }) => {\r\n    //     if (pug) {\r\n    //       revisePugList(discriminator, pug, 'update');\r\n    //       pug.list.length === parseInt(pug.noPlayers) ? acc.push(pug) : null;\r\n    //     }\r\n    //     return acc;\r\n    //   }, []);\r\n    //   message.channel\r\n    //     .send(status ? printPugJoinStatus(result) : msg)\r\n    //     .catch(console.error + ':join:');\r\n\r\n    //   const forBroadcast = filledPugs.map(pug => {\r\n    //     if (PugList[pug.discriminator].picking) {\r\n    //       const allLeaveMsgs = Object.values(PugList).reduce((acc, op) => {\r\n    //         if (pug.discriminator !== op.discriminator) {\r\n    //           const allPugLeaveMsgs = pug.list.reduce((prev, user) => {\r\n    //             const { result } = leaveGameType(\r\n    //               ['l', op.discriminator],\r\n    //               user,\r\n    //               Pugs,\r\n    //               PugList\r\n    //             );\r\n    //             if (result[0].pug) {\r\n    //               revisePugList(\r\n    //                 op.discriminator,\r\n    //                 result[0].pug,\r\n    //                 result[0].pug.list.length === 0 ? 'remove' : 'update'\r\n    //               );\r\n    //               const msg = printPugLeaveStatus(result);\r\n    //               prev += `${msg} `;\r\n    //             }\r\n    //             return prev;\r\n    //           }, ``);\r\n    //           acc += `${allPugLeaveMsgs} \\n`;\r\n    //         }\r\n    //         return acc;\r\n    //       }, ``);\r\n    //       allLeaveMsgs && message.channel.send(allLeaveMsgs);\r\n    //       return pug;\r\n    //     }\r\n    //   });\r\n    //   forBroadcast.length > 0\r\n    //     ? message.channel.send(\r\n    //         broadCastFilledPugs(forBroadcast.filter(Boolean))\r\n    //       )\r\n    //     : null;\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.leavegametype.includes(action): {\r\n    //   const { status, result, msg } = leaveGameType(args, user, Pugs, PugList);\r\n    //   const deadPugs = result.reduce((acc, { pug, discriminator }) => {\r\n    //     if (pug) {\r\n    //       revisePugList(\r\n    //         discriminator,\r\n    //         pug,\r\n    //         pug.list.length === 0 ? 'remove' : 'update'\r\n    //       );\r\n    //       pug.list.length === parseInt(pug.noPlayers) - 1\r\n    //         ? acc.push({ ...pug, user })\r\n    //         : null;\r\n    //     }\r\n    //     return acc;\r\n    //   }, []);\r\n    //   message.channel\r\n    //     .send(status ? printPugLeaveStatus(result, args[1] === offline) : msg)\r\n    //     .catch(console.error + ':leave:');\r\n    //   deadPugs.length > 0\r\n    //     ? message.channel.send(broadCastDeadPugs(deadPugs))\r\n    //     : null;\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.listgametype.includes(action): {\r\n    //   const { status, result, msg } = listAvailablePugs(args, PugList);\r\n    //   message.channel\r\n    //     .send(status ? printPugStatuses(result) : msg)\r\n    //     .catch(console.error + ':list:');\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.pickplayer.includes(action): {\r\n    //   if (hasAdminCmd && !isValidAdminCmd) break;\r\n\r\n    //   const { status, result, msg } = pickPugPlayer(\r\n    //     isValidAdminCmd ? args.slice(1) : args,\r\n    //     isValidAdminCmd ? userMentioned : user,\r\n    //     PugList\r\n    //   );\r\n\r\n    //   status\r\n    //     ? revisePugList(\r\n    //         result.pug.discriminator,\r\n    //         result.pug,\r\n    //         !result.picking ? 'remove' : 'update'\r\n    //       )\r\n    //     : null;\r\n    //   message.channel\r\n    //     .send(\r\n    //       status\r\n    //         ? printPickStatus(result)\r\n    //         : msg || `**${result.pickedPlayers.username}** is already picked`\r\n    //     )\r\n    //     .catch(console.error + ':pick:');\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.captain.includes(action): {\r\n    //   const { status, result, msg } = addCaptain(user, PugList);\r\n    //   status\r\n    //     ? revisePugList(result.pug.discriminator, result.pug, 'update')\r\n    //     : null;\r\n    //   await message.channel\r\n    //     .send(status ? printAddCaptainStatus(user, result) : msg)\r\n    //     .catch(console.error + ':pick:');\r\n\r\n    //   status && result.captainsReady\r\n    //     ? pugEventEmitter.emit(\r\n    //         pugEvents.captainsReady,\r\n    //         result.pug.discriminator\r\n    //       )\r\n    //     : null;\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.picking.includes(action): {\r\n    //   const { status, result, msg } = listCurrentPickings(args, Pugs, PugList);\r\n    //   message.channel.send(status ? printPickingPugsStatus(result.pugs) : msg);\r\n    //   break;\r\n    // }\r\n\r\n    // case commands.promote.includes(action): {\r\n    //   const { status, result, msg } = promoteAvailablePugs(args, PugList);\r\n    //   status ? message.channel.send(printPromoteStatus(result.pugs)) : null;\r\n    //   break;\r\n    // }\r\n\r\n    default:\r\n      console.log('no match');\r\n  }\r\n}\r\n\r\n/**\r\n * C A C H E\r\n *    S E T U P\r\n *       A N D\r\n *         M A N I P U L A T I O N\r\n */\r\n\r\n(async () => {\r\n  cachedDB = await API.getCopyOfDB(`/`);\r\n  bot.login(process.env.DISCORD_BOT_TOKEN);\r\n})();\r\n\r\nconst updateCache = (serverId, toUpdate, newCache) =>\r\n  (cachedDB[serverId][toUpdate] = newCache);\r\n\r\n// const revisePugList = (discriminator, pug, action) => {\r\n//   if (action === 'update') PugList[discriminator] = pug;\r\n//   else if (action === 'remove' && PugList[discriminator])\r\n//     delete PugList[discriminator];\r\n// };\r\n\r\n/**\r\n * P U G\r\n *    E V E N T S\r\n */\r\n// pugEventEmitter.on(pugEvents.captainsReady, discriminator => {\r\n//   const { Channel = {} } = cachedDB;\r\n//   const pug = PugList[discriminator];\r\n//   bot.channels\r\n//     .get(Channel.preferredChannel)\r\n//     .send(broadCastCaptainsReady(pug))\r\n//     .catch(console.error + ':broadCastCaptains:');\r\n// });\r\n"]}